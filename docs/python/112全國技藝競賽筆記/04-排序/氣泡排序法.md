# 氣泡排序法

## 基本概念

1. **比較相鄰元素**：從數列的第**最後一個**元素開始，依次比較相鄰的兩個元素。
2. **交換位置**：如果前一個元素大於後一個元素，則交換這兩個元素的位置。
3. **重複過程**：對整個數列進行多次遍歷，每次遍歷都將最大的元素移至末尾。
4. **結束條件**：當一輪遍歷中沒有進行任何交換時，表示數列已經排好序，可以停止排序。

## 排序過程示例

假設有一串數字：$7, 5, 9, 1, 3$。以下是插入排序的具體過程：

- **第一輪**：
  - $1, 3$比對，不需移動，保持不變。
  - $9, 1$比對，交換，變為$7, 5, 1, 9, 3$。
  - $5, 1$比對，交換，變為$7, 1, 5, 9, 3$。
  - $7, 1$比對，交換，變為$1, 7, 5, 9, 3$。
  - 第一輪結果:$1, 7, 5, 9, 3$
- **第二輪**：
  - $9, 3$比對，交換，變為$1, 7, 5, 3, 9$。
  - $5, 3$比對，交換，變為$1, 7, 3, 5, 9$。
  - $7, 3$比對，交換，變為$1, 3, 7, 5, 9$。
  - $1, 3$比對，不需移動，保持不變。
  - 第二輪結果:$1, 3, 7, 5, 9$
- **第三輪**：
  - $5, 9$比對，不需移動，保持不變。
  - $7, 5$比對，交換，變為$1, 3, 5, 7, 9$。
  - 繼續比對，但都不需交換
最終答案：$1, 3, 5, 7, 9$

## 程式碼範例

### Problem H Bubble sort，計算swaps次數
```py
for _ in range(int(input())):
    n = int(input())
    ary = list(map(int, input().split()))
    count = 0
    for i in range(len(ary)):
        for j in range(i, len(ary)):
            if ary[i] > ary[j]:
                ary[i], ary[j] = ary[j], ary[i]
                count += 1
    print(f'Optimal train swapping takes {count} swaps.')
```

### TA001 排序練習 氣泡排序法
```python
import sys

for line in sys.stdin.read().splitlines():
    nums = list(map(int, line.split(", ")))
    n = len(nums)
    for i in range(n - 1):
        for j in range(n - i - 1):
            if nums[j] > nums[j + 1]:
                nums[j], nums[j + 1] = nums[j + 1], nums[j]
        if i == 1:
            break
    print(nums)
```

## 特點

- **時間複雜度**：
  - 最佳情況：$O(n)$，當數列已經排好序時。
  - 最壞情況：$O(n^2)$，當數列完全逆序時。
  - 平均情況：$O(n^2)$。
  
- **空間複雜度**：$O(1)$，因為它是一種原地排序演算法，不需要額外的存儲空間。

- **穩定性**：氣泡排序是一種穩定的排序演算法，相同值的元素在排序後相對位置不會改變。
