import{_ as l,c as p,m as i,a as s,J as h,w as k,V as n,E as t,o as e}from"./chunks/framework.CiAxhH1b.js";const m=JSON.parse('{"title":"貝爾曼-福特演算法 Bellman–Ford 演算法","description":"","frontmatter":{},"headers":[],"relativePath":"python/112全國技藝競賽筆記/12-圖形最短路徑演算法/Bellman–Ford演算法.md","filePath":"python/112全國技藝競賽筆記/12-圖形最短路徑演算法/Bellman–Ford演算法.md","lastUpdated":1729437298000}'),d={name:"python/112全國技藝競賽筆記/12-圖形最短路徑演算法/Bellman–Ford演算法.md"},r=n("",7),g=i("code",null,"O(V*E)",-1),y=i("code",null,"V",-1),A=i("code",null,"E",-1),D=i("h2",{id:"學習資源",tabindex:"-1"},[s("學習資源 "),i("a",{class:"header-anchor",href:"#學習資源","aria-label":'Permalink to "學習資源"'},"​")],-1),E=n("",6);function B(C,c,o,_,u,f){const a=t("VPNolebaseInlineLinkPreview");return e(),p("div",null,[r,i("p",null,[s("貝爾曼-福德演算法的複雜度是 "),g,s("，其中 "),y,s(" 是節點數量，"),A,s(" 是邊的數量。這個演算法的主要優勢是它的彈性，它可以處理各種圖形，包括存在負權重邊的情況，並識別出負環路。然而，它在某些情況下可能不如"),h(a,{href:"./Dijkstra's演算法"},{default:k(()=>[s("Dijkstra")]),_:1}),s("演算法效率高，特別是在圖比較稀疏的情況下。")]),D,i("ul",null,[i("li",null,[h(a,{href:"https://ithelp.ithome.com.tw/articles/10209748",target:"_blank",rel:"noreferrer"},{default:k(()=>[s("[演算法] 最短路徑 (Bellman-Ford 演算法)")]),_:1})]),i("li",null,[h(a,{href:"https://ithelp.ithome.com.tw/articles/10209845",target:"_blank",rel:"noreferrer"},{default:k(()=>[s("[演算法] 最短路徑 (Bellman-Ford 演算法 - 佇列優化)")]),_:1})])]),E])}const v=l(d,[["render",B]]);export{m as __pageData,v as default};
