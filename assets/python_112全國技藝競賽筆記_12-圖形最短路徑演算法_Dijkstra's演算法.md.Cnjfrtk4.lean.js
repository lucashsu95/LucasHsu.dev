import{_ as l,c as t,m as s,a as i,J as h,w as k,V as n,E as p,o as e}from"./chunks/framework.CiAxhH1b.js";const T=JSON.parse(`{"title":"戴克斯特拉 Dijkstra's演算法","description":"","frontmatter":{},"headers":[],"relativePath":"python/112全國技藝競賽筆記/12-圖形最短路徑演算法/Dijkstra's演算法.md","filePath":"python/112全國技藝競賽筆記/12-圖形最短路徑演算法/Dijkstra's演算法.md","lastUpdated":1729437298000}`),r={name:"python/112全國技藝競賽筆記/12-圖形最短路徑演算法/Dijkstra's演算法.md"},d=s("h1",{id:"戴克斯特拉-dijkstra-s演算法",tabindex:"-1"},[i("戴克斯特拉 Dijkstra's演算法 "),s("a",{class:"header-anchor",href:"#戴克斯特拉-dijkstra-s演算法","aria-label":`Permalink to "戴克斯特拉 Dijkstra's演算法"`},"​")],-1),g=s("h2",{id:"介紹",tabindex:"-1"},[i("介紹 "),s("a",{class:"header-anchor",href:"#介紹","aria-label":'Permalink to "介紹"'},"​")],-1),y=s("p",null,[i("Dijkstra演算法是一種用於解決"),s("strong",null,"最短路徑問題"),i("的演算法。它可以用來找出從一個起點到所有其他節點的最短路徑，或者找出兩個特定節點之間的最短路徑。Dijkstra演算法通常應用在以下情況：")],-1),A=n("",4),D=s("strong",null,"最小生成樹",-1),C=s("span",{class:"m"},"構建最小生成樹",-1),E=s("span",{class:"m"},"無法處理包含負權重",-1),B=s("span",{class:"m"},"密集圖和大型圖，Dijkstra演算法的效能可能不佳",-1),c=s("code",null,"A*搜索",-1),o=s("h2",{id:"學習資源",tabindex:"-1"},[i("學習資源 "),s("a",{class:"header-anchor",href:"#學習資源","aria-label":'Permalink to "學習資源"'},"​")],-1),F=s("h2",{id:"牛刀小試",tabindex:"-1"},[i("牛刀小試 "),s("a",{class:"header-anchor",href:"#牛刀小試","aria-label":'Permalink to "牛刀小試"'},"​")],-1),_=s("p",null,"Leetcode的",-1),u=s("s",null,"這題好像用BFS就可以做了...但我還是要放",-1),m=n("",4);function f(q,b,x,j,v,w){const a=p("VPNolebaseInlineLinkPreview");return e(),t("div",null,[d,g,y,s("ol",null,[A,s("li",null,[s("p",null,[D,i("：Dijkstra演算法的變體也可用於"),C,i("，這在最小生成樹問題中非常有用，也可以使用"),h(a,{href:"./../08-樹Tree/最小成本生成樹"},{default:k(()=>[i("併查集 Disjoint Set 與 Union Find")]),_:1}),i("。")])])]),s("p",null,[i("需要注意的是，Dijkstra演算法"),E,i("邊的圖，如果圖中存在負權重邊，則可能需要使用"),h(a,{href:"./Bellman–Ford演算法"},{default:k(()=>[i("貝爾曼-福德(Bellman–Ford)演算法")]),_:1}),i("。此外，對於"),B,i("，而其他演算法如"),c,i("等可能更為適用。")]),o,s("ul",null,[s("li",null,[h(a,{href:"https://ithelp.ithome.com.tw/articles/10209593",target:"_blank",rel:"noreferrer"},{default:k(()=>[i("達標好文 [演算法] 最短路徑 (Dijkstra 演算法)")]),_:1})])]),F,_,s("ul",null,[s("li",null,[h(a,{href:"https://leetcode.com/problems/second-minimum-time-to-reach-destination/description/?envType=daily-question&envId=2024-07-28",target:"_blank",rel:"noreferrer"},{default:k(()=>[i("2045. Second Minimum Time to Reach Destination")]),_:1}),u])]),m])}const S=l(r,[["render",f]]);export{T as __pageData,S as default};
