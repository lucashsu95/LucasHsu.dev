import{_ as e,c as r,m as i,a as s,J as a,w as n,V as l,E as k,o as d}from"./chunks/framework.eCHlHWUN.js";const v=JSON.parse('{"title":"貝爾曼-福特演算法 Bellman–Ford 演算法","description":"","frontmatter":{},"headers":[],"relativePath":"python/112全國技藝競賽筆記/12-圖形最短路徑演算法/Bellman–Ford演算法.md","filePath":"python/112全國技藝競賽筆記/12-圖形最短路徑演算法/Bellman–Ford演算法.md","lastUpdated":1729442892000}'),g={name:"python/112全國技藝競賽筆記/12-圖形最短路徑演算法/Bellman–Ford演算法.md"},y=l("",7),A=i("code",null,"O(V*E)",-1),D=i("code",null,"V",-1),E=i("code",null,"E",-1),B=i("h2",{id:"學習資源",tabindex:"-1"},[s("學習資源 "),i("a",{class:"header-anchor",href:"#學習資源","aria-label":'Permalink to "學習資源"'},"​")],-1),C=l("",6);function c(o,_,u,f,F,m){const h=k("VPNolebaseInlineLinkPreview"),p=k("NolebaseGitContributors"),t=k("NolebaseGitChangelog");return d(),r("div",null,[y,i("p",null,[s("貝爾曼-福德演算法的複雜度是 "),A,s("，其中 "),D,s(" 是節點數量，"),E,s(" 是邊的數量。這個演算法的主要優勢是它的彈性，它可以處理各種圖形，包括存在負權重邊的情況，並識別出負環路。然而，它在某些情況下可能不如"),a(h,{href:"./Dijkstra's演算法"},{default:n(()=>[s("Dijkstra")]),_:1}),s("演算法效率高，特別是在圖比較稀疏的情況下。")]),B,i("ul",null,[i("li",null,[a(h,{href:"https://ithelp.ithome.com.tw/articles/10209748",target:"_blank",rel:"noreferrer"},{default:n(()=>[s("[演算法] 最短路徑 (Bellman-Ford 演算法)")]),_:1})]),i("li",null,[a(h,{href:"https://ithelp.ithome.com.tw/articles/10209845",target:"_blank",rel:"noreferrer"},{default:n(()=>[s("[演算法] 最短路徑 (Bellman-Ford 演算法 - 佇列優化)")]),_:1})])]),C,a(p),a(t)])}const q=e(g,[["render",c]]);export{v as __pageData,q as default};
